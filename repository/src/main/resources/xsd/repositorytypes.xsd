<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2020 rel. 2 sp1 (x64) (http://www.altova.com) by Don Mendelson (FIX Protocol Ltd. (FPL)) -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:fixr="http://fixprotocol.io/2020/orchestra/repository" targetNamespace="http://fixprotocol.io/2020/orchestra/repository" elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.0">
	<xs:annotation>
		<xs:documentation>
			Â© Copyright 2016-2020 FIX Protocol Limited Creative
			Commons Attribution-NoDerivatives 4.0
			International Public License
		</xs:documentation>
	</xs:annotation>
	<xs:simpleType name="Abbreviation_t">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:complexType name="actionType">
		<xs:sequence>
			<xs:choice id="parameters" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Event parameters</xs:documentation>
				</xs:annotation>
				<xs:element name="field" type="fixr:fieldType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
				<xs:element name="component" type="fixr:componentType"/>
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="group" type="fixr:groupType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
			</xs:choice>
			<xs:choice id="actions" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Any number of action behaviors can be triggered at the same time.</xs:documentation>
				</xs:annotation>
				<xs:element name="messageRef" type="fixr:messageRefType">
					<xs:annotation>
						<xs:documentation>Send a message</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="assign" type="fixr:expressionType">
					<xs:annotation>
						<xs:documentation>Content of element holds an assignment expression
							for a state variable in the form '$actor.variable=value'
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="trigger" type="fixr:triggerType">
					<xs:annotation>
						<xs:documentation>Trigger a state transtion in a state machine</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="timerSchedule" type="fixr:timerSchedule"/>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="actorType">
		<xs:annotation>
			<xs:documentation>Represents a class of participants</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>State variables</xs:documentation>
				</xs:annotation>
				<xs:element name="field" type="fixr:fieldType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
				<xs:element name="component" type="fixr:componentType"/>
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="group" type="fixr:groupType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="states" type="fixr:stateMachineType"/>
				<xs:element name="timer" type="fixr:timerType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:complexType name="annotation">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="documentation" type="fixr:documentation"/>
			<xs:element name="appinfo" type="fixr:appinfo"/>
		</xs:choice>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:complexType name="appinfo" mixed="true">
		<xs:annotation>
			<xs:documentation>Usage specific annotation, optionally with link to
				an external reference or standard
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:any processContents="lax"/>
		</xs:sequence>
		<xs:attribute name="specUrl" type="xs:anyURI">
			<xs:annotation>
				<xs:documentation>Reference documentation</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="langId" type="fixr:language_t"/>
		<xs:attribute name="purpose" type="fixr:purpose_t"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:anyAttribute namespace="##other" processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="blockAssignmentType">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="componentRef" type="fixr:componentRefType"/>
			<xs:element name="groupRef" type="fixr:groupRefType"/>
			<xs:element name="fieldRef" type="fixr:fieldRefType"/>
		</xs:choice>
	</xs:complexType>
	<xs:simpleType name="CatComponentType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Field"/>
			<xs:enumeration value="Message"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CategoryComponentType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Field"/>
			<xs:enumeration value="Message"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="categoryType">
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t"/>
		<xs:attribute name="FIXMLFileName" type="fixr:Name_t"/>
		<xs:attribute name="componentType" type="fixr:CatComponentType_t"/>
		<xs:attribute name="section" type="fixr:Name_t"/>
		<xs:attribute name="includeFile" type="fixr:CatIncludeFile_t"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:simpleType name="CatIncludeFile_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="components"/>
			<xs:enumeration value="fields"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="changeType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Editorial"/>
			<xs:enumeration value="Definitional"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="codeSetType">
		<xs:sequence>
			<xs:element name="code" type="fixr:codeType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="type" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Underlying FIX datatype of codes
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="default" type="xs:string"/>
		<xs:attribute name="specUrl" type="xs:anyURI">
			<xs:annotation>
				<xs:documentation>Reference documentation for an external code set
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:complexType name="codeType">
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="value" type="xs:string" use="required"/>
		<xs:attribute name="sort" type="xs:string"/>
		<xs:attribute name="group" type="xs:string"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:simpleType name="CompID_t">
		<xs:restriction base="xs:positiveInteger">
			<xs:minInclusive value="1000"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ComponentName_t">
		<xs:restriction base="fixr:Name_t"/>
	</xs:simpleType>
	<xs:complexType name="componentRefType">
		<xs:sequence>
			<xs:element name="blockAssignment" type="fixr:blockAssignmentType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Specifies a how a component or each group entry is populated (optional)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="rule" type="fixr:componentRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Rule to tell when a conditionally require component
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:refidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="presence" type="fixr:presence_t" default="optional"/>
		<xs:attribute name="instanceName" type="fixr:ComponentName_t">
			<xs:annotation>
				<xs:documentation>Override the component name for this instance, for
					code generation and the like. Allows more than one instance of a
					component in a message.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="componentRuleType">
		<xs:sequence>
			<xs:element name="when" type="fixr:expressionType"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Name of this rule</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="presence" type="fixr:presence_t">
			<xs:annotation>
				<xs:documentation>Overrides presence when expression is true</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="componentType">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="which" type="fixr:memberType"/>
	</xs:complexType>
	<xs:complexType name="conceptType">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
				<xs:element name="messageRef" type="fixr:messageRefType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:attributeGroup name="containerAttribGrp">
		<xs:attribute name="latestEP" type="fixr:EP_t"/>
	</xs:attributeGroup>
	<xs:simpleType name="datatypeStandard_enum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ISO11404">
				<xs:annotation>
					<xs:documentation>General Purpose Datatypes</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="GPB">
				<xs:annotation>
					<xs:documentation>Google Protocol Buffers</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="JSON">
				<xs:annotation>
					<xs:documentation>JSON Schema</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SBE">
				<xs:annotation>
					<xs:documentation>Simple Binary Encoding</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="XML">
				<xs:annotation>
					<xs:documentation>XML Schema and FIXML</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TAG_VALUE">
				<xs:annotation>
					<xs:documentation>FIX classic encoding</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="datatypeStandard_t">
		<xs:annotation>
			<xs:documentation>Extensible datatype standards</xs:documentation>
		</xs:annotation>
		<xs:union memberTypes="fixr:datatypeStandard_enum xs:string"/>
	</xs:simpleType>
	<xs:complexType name="documentation" mixed="true">
		<xs:sequence>
			<xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="langId" type="fixr:language_t"/>
		<xs:attribute name="purpose" type="fixr:purpose_t"/>
		<xs:attribute name="contentType" type="fixr:mime_t" default="text/plain"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:simpleType name="Edition_t">
		<xs:restriction base="xs:string">
			<xs:maxLength value="8"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="entityAttribGrp">
		<xs:attribute name="added" type="fixr:Version_t"/>
		<xs:attribute name="addedEP" type="fixr:EP_t"/>
		<xs:attribute name="changeType" type="fixr:changeType_t"/>
		<xs:attribute name="deprecated" type="fixr:Version_t"/>
		<xs:attribute name="deprecatedEP" type="fixr:EP_t"/>
		<xs:attribute name="issue" type="xs:string"/>
		<xs:attribute name="lastModified" type="fixr:Version_t"/>
		<xs:attribute name="replaced" type="fixr:Version_t"/>
		<xs:attribute name="replacedEP" type="fixr:EP_t"/>
		<xs:attribute name="replacedByField" type="fixr:id_t"/>
		<xs:attribute name="supported" type="fixr:supportType" default="supported"/>
		<xs:attribute name="updated" type="fixr:Version_t"/>
		<xs:attribute name="updatedEP" type="fixr:EP_t"/>
	</xs:attributeGroup>
	<xs:simpleType name="EP_t">
		<xs:restriction base="xs:integer"/>
	</xs:simpleType>
	<xs:simpleType name="expressionType">
		<xs:annotation>
			<xs:documentation>Expressed in a Domain Specific Language
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:maxLength value="1024"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="fieldAttribGrp">
		<xs:annotation>
			<xs:documentation>Attributes of a field that be overridden by a rule
			</xs:documentation>
		</xs:annotation>
		<xs:attribute name="minInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive lower bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="maxInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive upper bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implLength" type="xs:short">
			<xs:annotation>
				<xs:documentation>Fixed length</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implMinLength" type="xs:short"/>
		<xs:attribute name="implMaxLength" type="xs:short"/>
		<xs:attribute name="presence" type="fixr:presence_t" default="optional"/>
		<xs:attribute name="encoding" type="xs:string">
			<xs:annotation>
				<xs:documentation>Character encoding if other than US-ASCII
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value" type="xs:string">
			<xs:annotation>
				<xs:documentation>If presence is optional, then it represents a
					default when the sender does not provide the field.
					If presence is constant, then it is the constant value.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="fieldRefType">
		<xs:sequence>
			<xs:element name="rule" type="fixr:fieldRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Rule to tell when a conditionally require field
						is required or forbidden, to override other attributes, or perform
						validation.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="assign" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Content of element holds an assignment expression
						for a message field or state variable
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:refidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="lengthId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a field used as a length prefix
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:fieldAttribGrp"/>
		<xs:attribute name="instanceName" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Override the field name for this instance, for
					code generation and the like. Allows more than one instance of a
					field in a message or component.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="fieldRuleType">
		<xs:sequence>
			<xs:sequence>
				<xs:element name="unique" minOccurs="0">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="fieldRef" type="fixr:fieldRefType" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>Other field or fields that scope uniqueness. 
									If none provided, then the field value must be globally unique.</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="assign" type="fixr:expressionType" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Content of element holds an assignment expression
							for a message field or state variable.
							This can be used for field validation.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:element name="when" type="fixr:expressionType"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Name of this rule</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="xs:string">
			<xs:annotation>
				<xs:documentation>Overrides the type of the referenced field.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:fieldAttribGrp"/>
	</xs:complexType>
	<xs:complexType name="fieldType">
		<xs:sequence>
			<xs:element name="rule" type="fixr:fieldRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Rule to tell when a conditionally require field
						is required or forbidden, to override other attributes, or perform
						validation.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="assign" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Content of element holds an assignment expression
						for a message field or state variable
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="type" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Attribute type refers to either a datatype or a
					codeSet, which carries an underlying datatype.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:fieldAttribGrp"/>
		<xs:attribute name="lengthId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a field used as a length prefix
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="discriminatorId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a field used as a discriminator for this field's domain
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="baseCategory" type="fixr:Name_t"/>
		<xs:attribute name="baseCategoryAbbrName" type="fixr:Name_t"/>
		<xs:attribute name="unionDataType" type="fixr:UnionDataType_t"/>
	</xs:complexType>
	<xs:complexType name="flowType">
		<xs:annotation>
			<xs:documentation>A stream of messages in one direction</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="source" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that originates messages
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destination" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that receives messages.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reliability" type="fixr:reliability_t"/>
	</xs:complexType>
	<xs:simpleType name="GroupName_t">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:complexType name="groupRefType">
		<xs:complexContent>
			<xs:extension base="fixr:componentRefType">
				<xs:attribute name="implMinOccurs" type="xs:nonNegativeInteger"/>
				<xs:attribute name="implMaxOccurs" type="fixr:unboundedIntType" default="unbounded"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="groupType">
		<xs:annotation>
			<xs:documentation>A repeating group. Logically, groupType is a subclass of componentType, but to make numInGroup first in the sequence, it cannot be an extension.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="numInGroup" type="fixr:fieldRefType" minOccurs="0"/>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implMinOccurs" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Lower bound of group instances (numInGroup)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implMaxOccurs" type="fixr:unboundedIntType" default="unbounded">
			<xs:annotation>
				<xs:documentation>Upper bound of group instances (numInGroup)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="which" type="fixr:memberType">
			<xs:annotation>
				<xs:documentation>Member selection within each group instance</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="id_t">
		<xs:restriction base="xs:positiveInteger"/>
	</xs:simpleType>
	<xs:complexType name="identifiersType">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="correlate" type="fixr:identifierType">
					<xs:annotation>
						<xs:documentation>Correlated field IDs between two message types</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="assign" type="fixr:identifierType">
					<xs:annotation>
						<xs:documentation>Field ID assigned</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="identifierType">
		<xs:attribute name="id" type="fixr:id_t" use="required">
			<xs:annotation>
				<xs:documentation>Field ID assigned or correlated in a message reference</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sourceId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Field ID correlated from source message. If not present, assumed to be same tag as 'id'.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="IncludeFile_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="components"/>
			<xs:enumeration value="fields"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="language_t">
		<xs:restriction base="xs:language"/>
	</xs:simpleType>
	<xs:complexType name="mappedDatatype">
		<xs:sequence>
			<xs:element name="extension" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A datatype may be mapped to an XML snippet in the native schema belonging to its encoding standard.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="standard" type="fixr:datatypeStandard_t" use="required"/>
		<xs:attribute name="builtin" type="xs:boolean"/>
		<xs:attribute name="base" type="xs:string"/>
		<xs:attribute name="pattern" type="xs:string"/>
		<xs:attribute name="element" type="xs:string"/>
		<xs:attribute name="parameter" type="xs:string"/>
		<xs:attribute name="minInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive lower bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="maxInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive upper bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="memberType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="oneOf">
				<xs:annotation>
					<xs:documentation>Members are mutually exclusive; exactly one must be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="anyOf">
				<xs:annotation>
					<xs:documentation>At least one of the members must be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="messageAttribGrp">
		<xs:attribute name="msgType" type="fixr:MsgType_t"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attribute name="abbrName" type="fixr:Abbreviation_t"/>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="messageRefType">
		<xs:sequence>
			<xs:element name="identifiers" type="fixr:identifiersType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="msgType" type="fixr:MsgType_t"/>
		<xs:attributeGroup ref="fixr:refidGrp"/>
		<xs:attribute name="implMinOccurs" type="xs:positiveInteger" default="1"/>
		<xs:attribute name="implMaxOccurs" type="fixr:unboundedIntType" default="unbounded">
			<xs:annotation>
				<xs:documentation>The same message type may be sent one or more times</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="messageType">
		<xs:sequence>
			<xs:element name="structure">
				<xs:complexType>
					<xs:choice maxOccurs="unbounded">
						<xs:element name="componentRef" type="fixr:componentRefType"/>
						<xs:element name="groupRef" type="fixr:groupRefType"/>
						<xs:element name="fieldRef" type="fixr:fieldRefType"/>
					</xs:choice>
					<xs:attribute name="which" type="fixr:memberType"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="responses" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="response" type="fixr:responseType" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Responses are evaluated and triggered in the order listed</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="msgType" type="fixr:MsgType_t"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="flow" type="fixr:Name_t"/>
	</xs:complexType>
	<xs:simpleType name="mime_t">
		<xs:annotation>
			<xs:documentation>Multipurpose Internet Mail Extensions (MIME) media type</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:minLength value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MsgType_t">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:maxLength value="2"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Name_t">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:maxLength value="255"/>
			<xs:pattern value="([A-Z]|[a-z])([0-9]|[A-Z]|[a-z]|_)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="oidGrp">
		<xs:annotation>
			<xs:documentation>The identifiers of a message element</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="fixr:id_t" use="required">
			<xs:annotation>
				<xs:documentation>Numeric identifier generally must be unique within a file for an element type, e.g. unique field tag</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="abbrName" type="fixr:Abbreviation_t"/>
		<xs:attribute name="scenario" type="fixr:Scenario_t" default="base">
			<xs:annotation>
				<xs:documentation>The use case of an element, distinguished by workflow, asset class, etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:simpleType name="presence_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="optional">
				<xs:annotation>
					<xs:documentation>The field or component MAY be present; it may be conditionally required based on a rule.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="required">
				<xs:annotation>
					<xs:documentation>The field or component MUST be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="forbidden">
				<xs:annotation>
					<xs:documentation>The field or component MUST NOT be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ignored">
				<xs:annotation>
					<xs:documentation>The field or component MAY be present but is not validated.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="constant">
				<xs:annotation>
					<xs:documentation>The field has a constant value; in some encodings it need not be sent on the wire.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="purpose_enum">
		<xs:annotation>
			<xs:documentation>Recommended annotation purposes</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="SYNOPSIS"/>
			<xs:enumeration value="ELABORATION"/>
			<xs:enumeration value="EXAMPLE"/>
			<xs:enumeration value="DISPLAY">
				<xs:annotation>
					<xs:documentation>For UI when different from canonical name; may
						have multi-language displays
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="purpose_t">
		<xs:annotation>
			<xs:documentation>Extensible annotation purposes</xs:documentation>
		</xs:annotation>
		<xs:union memberTypes="fixr:purpose_enum xs:string"/>
	</xs:simpleType>
	<xs:attributeGroup name="refidGrp">
		<xs:annotation>
			<xs:documentation>A reference to a message element by its key identifiers</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="fixr:id_t" use="required">
			<xs:annotation>
				<xs:documentation>Numeric identifier generally must be unique within a file for an element type, e.g. unique field tag</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scenario" type="fixr:Scenario_t" default="base">
			<xs:annotation>
				<xs:documentation>The use case of an element, distinguished by workflow, asset class, etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:simpleType name="reliability_t">
		<xs:annotation>
			<xs:documentation>Message delivery gurantee</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="bestEffort"/>
			<xs:enumeration value="idempotent"/>
			<xs:enumeration value="recoverable"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="responseType">
		<xs:annotation>
			<xs:documentation>Any number of action behaviors can be triggered by the same 'when' condition</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="fixr:actionType">
				<xs:sequence>
					<xs:element name="when" type="fixr:expressionType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A common condition for all of the actions. If it
						evalutes true, then the actions are invoked. If 'when' is not
						present, the actions are unconditional.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="name" type="fixr:Name_t"/>
				<xs:attribute name="sync" type="fixr:synchronization" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="Scenario_t">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:maxLength value="255"/>
			<xs:pattern value="([A-Z]|[a-z])([0-9]|[A-Z]|[a-z]|_|-)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="sectionType">
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t"/>
		<xs:attribute name="displayOrder" type="xs:int"/>
		<xs:attribute name="FIXMLFileName" type="fixr:Name_t"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:simpleType name="Sort_t">
		<xs:restriction base="xs:nonNegativeInteger"/>
	</xs:simpleType>
	<xs:complexType name="stateMachineType">
		<xs:sequence>
			<xs:element name="initial" type="fixr:stateType">
				<xs:annotation>
					<xs:documentation>Initial state of a state machine</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="state" type="fixr:stateType" maxOccurs="unbounded"/>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:complexType name="stateType">
		<xs:annotation>
			<xs:documentation>A state of a state machine. If it has no transitions, then it is a final state.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="transition" type="fixr:transitionType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="onentry" type="fixr:actionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Operation fired when entering a state.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="activity" type="fixr:actionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Operation fired when entering a state and completing when exiting or earlier.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="onexit" type="fixr:actionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Operation fired when exiting a state.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:simpleType name="supportType">
		<xs:annotation>
			<xs:documentation>Support level</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="supported"/>
			<xs:enumeration value="forbidden"/>
			<xs:enumeration value="ignored"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="synchronization">
		<xs:restriction base="xs:string">
			<xs:enumeration value="asynchronous">
				<xs:annotation>
					<xs:documentation>Event timing is completely independent</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="synchronous">
				<xs:annotation>
					<xs:documentation>Requests in-progress block subsequent requests</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="pipelined">
				<xs:annotation>
					<xs:documentation>Response timing is dependent on a request, but multiple requests can be in-flight</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Term_t">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:simpleType name="timerOperation">
		<xs:restriction base="xs:string">
			<xs:enumeration value="START"/>
			<xs:enumeration value="CANCEL"/>
			<xs:enumeration value="RESET">
				<xs:annotation>
					<xs:documentation>Cancel and restart</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="timerSchedule">
		<xs:sequence>
			<xs:element name="activity" type="fixr:actionType">
				<xs:annotation>
					<xs:documentation>Action to take when a timer expires
								</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="actor" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that owns the timer
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the timer</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="operation" type="fixr:timerOperation" use="required"/>
		<xs:attribute name="interval" type="xs:duration"/>
	</xs:complexType>
	<xs:complexType name="timerType">
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:complexType name="transitionType">
		<xs:sequence>
			<xs:element name="when" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional guard condition. The transition is
						allowed if the condition evaluates true. If not present, the
						transition is unconditional.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="target" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The target state of the transition
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="triggerType">
		<xs:attribute name="stateMachine" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the state machine</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="actor" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that owns the state machine
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the transition to invoke
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="unbounded">
		<xs:restriction base="xs:string">
			<xs:enumeration value="unbounded"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="unboundedIntType">
		<xs:union memberTypes="xs:nonNegativeInteger fixr:unbounded"/>
	</xs:simpleType>
	<xs:simpleType name="UnionDataType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Qty"/>
			<xs:enumeration value="Reserved100Plus"/>
			<xs:enumeration value="Reserved1000Plus"/>
			<xs:enumeration value="Reserved4000Plus"/>
			<xs:enumeration value="Tenor"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Usage_t">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:simpleType name="Version_t">
		<xs:restriction base="xs:string">
			<xs:annotation>
				<xs:documentation>Enumerated FIX versions or major.minor or date as
					yyyymmdd of any protocol
				</xs:documentation>
			</xs:annotation>
			<xs:pattern value="(FIX.2.7)|(FIX.3.0)|(FIX\.4\.[0-4])|((FIX.Latest|(FIX\.5\.0(SP\d{1,2})?))(_EP((9[8-9])|([1-9][0-9][0-9])))?)|(FIXT.1.1)|([0-9]+)\.([0-9]+)|(\d{8})"/>
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
