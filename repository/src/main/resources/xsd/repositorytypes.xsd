<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:fixr="http://fixprotocol.io/2024/orchestra/repository" targetNamespace="http://fixprotocol.io/2024/orchestra/repository" elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.1-rc1">
	<xs:annotation>
		<xs:documentation>
			Â© Copyright 2016-2024 FIX Protocol Limited Creative
			Commons Attribution-NoDerivatives 4.0
			International Public License
		</xs:documentation>
	</xs:annotation>
	<xs:complexType name="actionType">
		<xs:sequence>
			<xs:choice id="parameters" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Event parameters</xs:documentation>
				</xs:annotation>
				<xs:element name="field" type="fixr:fieldType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
				<xs:element name="component" type="fixr:componentType"/>
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="group" type="fixr:groupType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
			</xs:choice>
			<xs:choice id="actions" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Any number of action behaviors can be triggered at the same time.</xs:documentation>
				</xs:annotation>
				<xs:element name="messageRef" type="fixr:messageRefType">
					<xs:annotation>
						<xs:documentation>Send a message</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="assign" type="fixr:expressionType">
					<xs:annotation>
						<xs:documentation>Content of element holds an assignment expression
							for a state variable in the form '$actor.variable=value'
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="trigger" type="fixr:triggerType">
					<xs:annotation>
						<xs:documentation>Trigger a state transtion in a state machine</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="timerSchedule" type="fixr:timerSchedule"/>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="actorType">
		<xs:annotation>
			<xs:documentation>Represents a class of participants</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>State variables</xs:documentation>
				</xs:annotation>
				<xs:element name="field" type="fixr:fieldType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
				<xs:element name="component" type="fixr:componentType"/>
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="group" type="fixr:groupType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="states" type="fixr:stateMachineType"/>
				<xs:element name="timer" type="fixr:timerType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:complexType name="annotation">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="documentation" type="fixr:documentation"/>
			<xs:element name="appinfo" type="fixr:appinfo"/>
		</xs:choice>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:complexType name="appinfo" mixed="true">
		<xs:annotation>
			<xs:documentation>Usage specific annotation, optionally with link to
				an external reference or standard
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:any processContents="lax"/>
		</xs:sequence>
		<xs:attribute name="specUrl" type="xs:anyURI">
			<xs:annotation>
				<xs:documentation>Reference documentation</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="langId" type="fixr:language_t"/>
		<xs:attribute name="purpose" type="fixr:purpose_t"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:anyAttribute namespace="##other" processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="blockAssignmentType">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="componentRef" type="fixr:componentRefType"/>
			<xs:element name="groupRef" type="fixr:groupRefType"/>
			<xs:element name="fieldRef" type="fixr:fieldRefType"/>
		</xs:choice>
	</xs:complexType>
	<xs:simpleType name="CatComponentType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Field"/>
			<xs:enumeration value="Message"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CategoryComponentType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Field"/>
			<xs:enumeration value="Message"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="categoryType">
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t"/>
		<xs:attribute name="FIXMLFileName" type="fixr:Name_t"/>
		<xs:attribute name="componentType" type="fixr:CatComponentType_t"/>
		<xs:attribute name="section" type="fixr:Name_t"/>
		<xs:attribute name="includeFile" type="fixr:CatIncludeFile_t"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:simpleType name="CatIncludeFile_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="components"/>
			<xs:enumeration value="fields"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="changeType_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Editorial"/>
			<xs:enumeration value="Definitional"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="codeSetType">
		<xs:sequence>
			<xs:element name="code" type="fixr:codeType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="type" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Underlying FIX datatype of codes
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="default" type="xs:string"/>
		<xs:attribute name="specUrl" type="xs:anyURI">
			<xs:annotation>
				<xs:documentation>Reference documentation for an external code set
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="unionDataType" type="fixr:UnionDataType_t"/>
	</xs:complexType>
	<xs:complexType name="codeType">
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="value" type="xs:token" use="required">
			<xs:annotation>
				<xs:documentation>The XML processor will remove line feeds, carriage returns, tabs, leading and trailing spaces, and multiple spaces. However, single internal spaces are allowed. May be further restricted by an external style.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sort" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Sort and group may be used to organize visualization of a code set.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="group" type="xs:string"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:simpleType name="CompID_t">
		<xs:restriction base="xs:positiveInteger">
			<xs:minInclusive value="1000"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ComponentName_t">
		<xs:restriction base="fixr:Name_t"/>
	</xs:simpleType>
	<xs:complexType name="componentRefType">
		<xs:sequence>
			<xs:element name="blockAssignment" type="fixr:blockAssignmentType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Specifies a how a component or each group entry is populated (optional)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="rule" type="fixr:componentRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Rule to tell when a conditionally require component
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:refidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="presence" type="fixr:presence_t" default="optional"/>
		<xs:attribute name="instanceName" type="fixr:ComponentName_t">
			<xs:annotation>
				<xs:documentation>Override the component name for this instance, for
					code generation and the like. Allows more than one instance of a
					component in a message.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="componentRuleType">
		<xs:sequence>
			<xs:element name="when" type="fixr:expressionType"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Name of this rule</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="presence" type="fixr:presence_t">
			<xs:annotation>
				<xs:documentation>Overrides presence when expression is true</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="componentType">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="which" type="fixr:memberType"/>
	</xs:complexType>
	<xs:complexType name="conceptType">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
				<xs:element name="messageRef" type="fixr:messageRefType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:simpleType name="datatypeStandard_enum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ISO11404">
				<xs:annotation>
					<xs:documentation>General Purpose Datatypes</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="GPB">
				<xs:annotation>
					<xs:documentation>Google Protocol Buffers</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="JSON">
				<xs:annotation>
					<xs:documentation>JSON Schema</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SBE">
				<xs:annotation>
					<xs:documentation>Simple Binary Encoding</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="XML">
				<xs:annotation>
					<xs:documentation>XML Schema and FIXML</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TAG_VALUE">
				<xs:annotation>
					<xs:documentation>FIX classic encoding</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="datatypeStandard_t">
		<xs:annotation>
			<xs:documentation>Extensible datatype standards</xs:documentation>
		</xs:annotation>
		<xs:union memberTypes="fixr:datatypeStandard_enum xs:string"/>
	</xs:simpleType>
	<xs:complexType name="documentation" mixed="true">
		<xs:sequence>
			<xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="langId" type="fixr:language_t"/>
		<xs:attribute name="purpose" type="fixr:purpose_t"/>
		<xs:attribute name="contentType" type="fixr:mime_t" default="text/plain"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:attributeGroup name="entityAttribGrp">
		<xs:attribute name="added" type="fixr:Version_t"/>
		<xs:attribute name="addedEP" type="fixr:EP_t"/>
		<xs:attribute name="changeType" type="fixr:changeType_t"/>
		<xs:attribute name="deprecated" type="fixr:Version_t"/>
		<xs:attribute name="deprecatedEP" type="fixr:EP_t"/>
		<xs:attribute name="issue" type="xs:string"/>
		<xs:attribute name="lastModified" type="fixr:Version_t"/>
		<xs:attribute name="replaced" type="fixr:Version_t"/>
		<xs:attribute name="replacedEP" type="fixr:EP_t"/>
		<xs:attribute name="replacedByField" type="fixr:id_t"/>
		<xs:attribute name="supported" type="fixr:supportType" default="supported"/>
		<xs:attribute name="updated" type="fixr:Version_t"/>
		<xs:attribute name="updatedEP" type="fixr:EP_t"/>
	</xs:attributeGroup>
	<xs:simpleType name="EP_t">
		<xs:restriction base="xs:integer"/>
	</xs:simpleType>
	<xs:simpleType name="expressionType">
		<xs:annotation>
			<xs:documentation>Expressed in a Domain Specific Language
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:maxLength value="1024"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="fieldAttribGrp">
		<xs:annotation>
			<xs:documentation>Attributes of a field that be overridden by a rule
			</xs:documentation>
		</xs:annotation>
		<xs:attribute name="minInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive lower bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="maxInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive upper bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implLength" type="xs:short">
			<xs:annotation>
				<xs:documentation>Fixed length</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implMinLength" type="xs:short"/>
		<xs:attribute name="implMaxLength" type="xs:short"/>
		<xs:attribute name="presence" type="fixr:presence_t" default="optional"/>
		<xs:attribute name="encoding" type="xs:string">
			<xs:annotation>
				<xs:documentation>Character encoding if other than US-ASCII
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value" type="xs:string">
			<xs:annotation>
				<xs:documentation>If presence is optional, then it represents a
					default when the sender does not provide the field.
					If presence is constant, then it is the constant value.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="fieldRefType">
		<xs:sequence>
			<xs:element name="rule" type="fixr:fieldRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Rule to tell when a conditionally require field
						is required or forbidden, to override other attributes, or perform
						validation.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="assign" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Content of element holds an assignment expression
						for a message field or state variable
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:refidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="lengthId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a field used as a length prefix
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="nonEncodedFieldId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a non-encoded field related to an encoded field
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:fieldAttribGrp"/>
		<xs:attribute name="instanceName" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Override the field name for this instance, for
					code generation and the like. Allows more than one instance of a
					field in a message or component.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="fieldRuleType">
		<xs:sequence>
			<xs:sequence>
				<xs:element name="unique" minOccurs="0">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="fieldRef" type="fixr:fieldRefType" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>Other field or fields that scope uniqueness.
									If none provided, then the field value must be globally unique.</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="assign" type="fixr:expressionType" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Content of element holds an assignment expression
							for a message field or state variable.
							This can be used for field validation.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:element name="when" type="fixr:expressionType"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Name of this rule</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Overrides the type of the referenced field.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:fieldAttribGrp"/>
	</xs:complexType>
	<xs:complexType name="fieldType">
		<xs:sequence>
			<xs:element name="rule" type="fixr:fieldRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Rule to tell when a conditionally require field
						is required or forbidden, to override other attributes, or perform
						validation.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="assign" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Content of element holds an assignment expression
						for a message field or state variable
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="type" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Attribute type refers to a datatype name
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="codeSet" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>Attribute codeSet refers to a codeSet name
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="fixr:fieldAttribGrp"/>
		<xs:attribute name="lengthId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a field used as a length prefix
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="nonEncodedFieldId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a non-encoded field related to an encoded field
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="discriminatorId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Identifies a field used as a discriminator for this field's domain
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="baseCategory" type="fixr:Name_t"/>
		<xs:attribute name="baseCategoryAbbrName" type="fixr:Name_t"/>
		<xs:attribute name="unionDataType" type="fixr:UnionDataType_t"/>
	</xs:complexType>
	<xs:complexType name="flowType">
		<xs:annotation>
			<xs:documentation>A stream of messages in one direction</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="source" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that originates messages
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destination" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that receives messages.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reliability" type="fixr:reliability_t"/>
	</xs:complexType>
	<xs:simpleType name="GroupName_t">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:complexType name="groupRefType">
		<xs:complexContent>
			<xs:extension base="fixr:componentRefType">
				<xs:attribute name="implMinOccurs" type="xs:nonNegativeInteger"/>
				<xs:attribute name="implMaxOccurs" type="fixr:unboundedIntType" default="unbounded"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="groupType">
		<xs:annotation>
			<xs:documentation>A repeating group. Logically, groupType is a subclass of componentType, but to make numInGroup first in the sequence, it cannot be an extension.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="numInGroup" type="fixr:fieldRefType" minOccurs="0"/>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="componentRef" type="fixr:componentRefType"/>
				<xs:element name="groupRef" type="fixr:groupRefType"/>
				<xs:element name="fieldRef" type="fixr:fieldRefType"/>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implMinOccurs" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Lower bound of group instances (numInGroup)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="implMaxOccurs" type="fixr:unboundedIntType" default="unbounded">
			<xs:annotation>
				<xs:documentation>Upper bound of group instances (numInGroup)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="which" type="fixr:memberType">
			<xs:annotation>
				<xs:documentation>Member selection within each group instance</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="id_t">
		<xs:restriction base="xs:positiveInteger"/>
	</xs:simpleType>
	<xs:complexType name="identifiersType">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded">
				<xs:element name="correlate" type="fixr:identifierType">
					<xs:annotation>
						<xs:documentation>Correlated field IDs between two message types</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="assign" type="fixr:identifierType">
					<xs:annotation>
						<xs:documentation>Field ID assigned</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="identifierType">
		<xs:attribute name="id" type="fixr:id_t" use="required">
			<xs:annotation>
				<xs:documentation>Field ID assigned or correlated in a message reference</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sourceId" type="fixr:id_t">
			<xs:annotation>
				<xs:documentation>Field ID correlated from source message. If not present, assumed to be same tag as 'id'.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="IncludeFile_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="components"/>
			<xs:enumeration value="fields"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="language_t">
		<xs:restriction base="xs:language"/>
	</xs:simpleType>
	<xs:complexType name="mappedDatatype">
		<xs:sequence>
			<xs:element name="extension" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A datatype may be mapped to an XML snippet in the native schema belonging to its encoding standard.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="standard" type="fixr:datatypeStandard_t" use="required"/>
		<xs:attribute name="builtin" type="xs:boolean"/>
		<xs:attribute name="base" type="xs:string">
			<xs:annotation>
				<xs:documentation>A datatype from which a subtype is created by restriction or a derived type is created by a generator</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pattern" type="xs:string">
			<xs:annotation>
				<xs:documentation>A lexical restriction from a base type</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="element" type="xs:string">
			<xs:annotation>
				<xs:documentation>Element type of an aggregate type such as an array or sequence</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="size" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Size of an aggregate type such as an array. That is, the number of elements.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="parameter" type="xs:string"/>
		<xs:attribute name="minInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive lower bound of values</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="maxInclusive" type="xs:string">
			<xs:annotation>
				<xs:documentation>Inclusive upper bound of values</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="memberType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="oneOf">
				<xs:annotation>
					<xs:documentation>Members are mutually exclusive; exactly one must be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="anyOf">
				<xs:annotation>
					<xs:documentation>At least one of the members must be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="messageRefType">
		<xs:sequence>
			<xs:element name="identifiers" type="fixr:identifiersType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="msgType" type="fixr:MsgType_t"/>
		<xs:attributeGroup ref="fixr:refidGrp"/>
		<xs:attribute name="implMinOccurs" type="xs:positiveInteger" default="1"/>
		<xs:attribute name="implMaxOccurs" type="fixr:unboundedIntType" default="unbounded">
			<xs:annotation>
				<xs:documentation>The same message type may be sent one or more times</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="messageType">
		<xs:sequence>
			<xs:element name="structure" minOccurs="0">
				<xs:complexType>
					<xs:choice maxOccurs="unbounded">
						<xs:element name="componentRef" type="fixr:componentRefType"/>
						<xs:element name="groupRef" type="fixr:groupRefType"/>
						<xs:element name="fieldRef" type="fixr:fieldRefType"/>
					</xs:choice>
					<xs:attribute name="which" type="fixr:memberType"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="when" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A condition that distinguishes when a scenario of a message type applies. It could be used to generate a decision tree to correlate an incoming message to its scenario, or to decide which scenario of a request message to send.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="responses" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="response" type="fixr:responseType" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Responses are evaluated and triggered in the order listed</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="msgType" type="fixr:MsgType_t"/>
		<xs:attribute name="category" type="fixr:Name_t"/>
		<xs:attributeGroup ref="fixr:oidGrp"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
		<xs:attribute name="flow" type="fixr:Name_t"/>
		<xs:attribute name="rendering" type="xs:string">
			<xs:annotation>
				<xs:documentation>A hint to processes about how to interpret the element. Not validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="mime_t">
		<xs:annotation>
			<xs:documentation>Multipurpose Internet Mail Extensions (MIME) media type</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:minLength value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MsgType_t">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:maxLength value="2"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Name_t">
		<xs:annotation>
			<xs:documentation>Names are from 1-64 characters. The XML processor will remove line feeds, carriage returns, tabs, leading and trailing spaces, and multiple spaces. Single internal spaces are allowed by the schema but may be restricted by an external style.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:minLength value="1"/>
			<xs:maxLength value="64"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="oidGrp">
		<xs:annotation>
			<xs:documentation>The identifiers of a message element</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="fixr:id_t" use="required">
			<xs:annotation>
				<xs:documentation>Numeric identifier generally must be unique within a file for an element type, e.g. unique field tag</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="abbrName" type="fixr:Name_t"/>
		<xs:attribute name="scenario" type="fixr:Name_t" default="base">
			<xs:annotation>
				<xs:documentation>The use case of an element, distinguished by workflow, asset class, etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scenarioId" type="fixr:id_t" default="1">
			<xs:annotation>
				<xs:documentation>Unique identifier of a scenario. Default is '1' for base scenario.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:simpleType name="presence_t">
		<xs:restriction base="xs:string">
			<xs:enumeration value="optional">
				<xs:annotation>
					<xs:documentation>The field or component MAY be present; it may be conditionally required based on a rule.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="required">
				<xs:annotation>
					<xs:documentation>The field or component MUST be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="forbidden">
				<xs:annotation>
					<xs:documentation>The field or component MUST NOT be present.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ignored">
				<xs:annotation>
					<xs:documentation>The field or component MAY be present but is not validated.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="constant">
				<xs:annotation>
					<xs:documentation>The field has a constant value; in some encodings it need not be sent on the wire.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="purpose_enum">
		<xs:annotation>
			<xs:documentation>Recommended annotation purposes</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="SYNOPSIS"/>
			<xs:enumeration value="ELABORATION"/>
			<xs:enumeration value="EXAMPLE"/>
			<xs:enumeration value="DISPLAY">
				<xs:annotation>
					<xs:documentation>For UI when different from canonical name; may
						have multi-language displays
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="purpose_t">
		<xs:annotation>
			<xs:documentation>Extensible annotation purposes</xs:documentation>
		</xs:annotation>
		<xs:union memberTypes="fixr:purpose_enum xs:string"/>
	</xs:simpleType>
	<xs:attributeGroup name="refidGrp">
		<xs:annotation>
			<xs:documentation>A reference to a message element by its key identifiers</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="fixr:id_t" use="required">
			<xs:annotation>
				<xs:documentation>Numeric identifier generally must be unique within a file for an element type, e.g. unique field tag</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t">
			<xs:annotation>
				<xs:documentation>The name is optional as part of a reference and only for convenience. It is not enforced by referential integrity. However, the name of the referred object is authoritative. A validator may check the consistency between the name used for the reference and the name of the referred object.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scenario" type="fixr:Name_t" default="base">
			<xs:annotation>
				<xs:documentation>The use case of an element, distinguished by workflow, asset class, etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scenarioId" type="fixr:id_t" default="1">
			<xs:annotation>
				<xs:documentation>Unique identifier of a scenario. Default is '1' for base scenario.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:simpleType name="reliability_t">
		<xs:annotation>
			<xs:documentation>Message delivery gurantee</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="bestEffort"/>
			<xs:enumeration value="idempotent"/>
			<xs:enumeration value="recoverable"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="responseType">
		<xs:annotation>
			<xs:documentation>Any number of action behaviors can be triggered by the same 'when' condition</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="fixr:actionType">
				<xs:sequence>
					<xs:element name="when" type="fixr:expressionType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A common condition for all of the actions. If it
						evalutes true, then the actions are invoked. If 'when' is not
						present, the actions are unconditional.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="name" type="fixr:Name_t"/>
				<xs:attribute name="sync" type="fixr:synchronization" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="scenarioType">
		<xs:annotation>
			<xs:documentation>The use case of an element, distinguished by workflow, asset class, etc.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="id" type="fixr:id_t" default="1">
			<xs:annotation>
				<xs:documentation>Unique numeric identifier. Default is '1' is for base scenario.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" default="base">
			<xs:annotation>
				<xs:documentation>Unique name</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="sectionType">
		<xs:sequence>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t"/>
		<xs:attribute name="displayOrder" type="xs:int"/>
		<xs:attribute name="FIXMLFileName" type="fixr:Name_t"/>
		<xs:attributeGroup ref="fixr:entityAttribGrp"/>
	</xs:complexType>
	<xs:complexType name="stateMachineType">
		<xs:sequence>
			<xs:element name="initial" type="fixr:stateType">
				<xs:annotation>
					<xs:documentation>Initial state of a state machine</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="state" type="fixr:stateType" maxOccurs="unbounded"/>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:complexType name="stateType">
		<xs:annotation>
			<xs:documentation>A state of a state machine. If it has no transitions, then it is a final state.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="transition" type="fixr:transitionType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="onentry" type="fixr:actionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Operation fired when entering a state.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="activity" type="fixr:actionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Operation fired when entering a state and completing when exiting or earlier.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="onexit" type="fixr:actionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Operation fired when exiting a state.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:simpleType name="supportType">
		<xs:annotation>
			<xs:documentation>Support level</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="supported"/>
			<xs:enumeration value="forbidden"/>
			<xs:enumeration value="ignored"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="synchronization">
		<xs:restriction base="xs:string">
			<xs:enumeration value="asynchronous">
				<xs:annotation>
					<xs:documentation>Event timing is completely independent</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="synchronous">
				<xs:annotation>
					<xs:documentation>Requests in-progress block subsequent requests</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="pipelined">
				<xs:annotation>
					<xs:documentation>Response timing is dependent on a request, but multiple requests can be in-flight</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="timerOperation">
		<xs:restriction base="xs:string">
			<xs:enumeration value="START"/>
			<xs:enumeration value="CANCEL"/>
			<xs:enumeration value="RESET">
				<xs:annotation>
					<xs:documentation>Cancel and restart</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="timerSchedule">
		<xs:sequence>
			<xs:element name="activity" type="fixr:actionType">
				<xs:annotation>
					<xs:documentation>Action to take when a timer expires
								</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="actor" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that owns the timer
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the timer</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="operation" type="fixr:timerOperation" use="required"/>
		<xs:attribute name="interval" type="xs:duration"/>
	</xs:complexType>
	<xs:complexType name="timerType">
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
	</xs:complexType>
	<xs:complexType name="transitionType">
		<xs:sequence>
			<xs:element name="when" type="fixr:expressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional guard condition. The transition is
						allowed if the condition evaluates true. If not present, the
						transition is unconditional.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="annotation" type="fixr:annotation" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="fixr:Name_t" use="required"/>
		<xs:attribute name="target" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The target state of the transition
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="triggerType">
		<xs:attribute name="stateMachine" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the state machine</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="actor" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the actor that owns the state machine
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="fixr:Name_t" use="required">
			<xs:annotation>
				<xs:documentation>Name of the transition to invoke
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="unbounded">
		<xs:restriction base="xs:string">
			<xs:enumeration value="unbounded"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="unboundedIntType">
		<xs:union memberTypes="xs:nonNegativeInteger fixr:unbounded"/>
	</xs:simpleType>
	<xs:simpleType name="UnionDataType_t">
		<xs:annotation>
			<xs:documentation>A second domain of valid values. The 'Reserved' types should only be applied Code Sets.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Qty"/>
			<xs:enumeration value="Reserved100Plus"/>
			<xs:enumeration value="Reserved1000Plus"/>
			<xs:enumeration value="Reserved4000Plus"/>
			<xs:enumeration value="Tenor"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Version_t">
		<xs:restriction base="xs:token">
			<xs:annotation>
				<xs:documentation>Uniquely identifies a revision. Many formats are possible, including but not limited to protocol version label, semantic versioning, date, or simple integer.
				The format may be restricted by an external style.
				</xs:documentation>
			</xs:annotation>
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
